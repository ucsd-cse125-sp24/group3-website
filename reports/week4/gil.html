<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torchlight Games</title>
    <link rel="stylesheet" href="../individualreport.css">

<body>
    <h1> Gil's Week 3 Individual Report </h1>

    <h2>What were your concrete goals for the week?</h2>
    <ul>
        <li>
            Complete a code review with group members on the initial implementation of the
            abstract game state redesign and improve where possible, then merge the new implementation 
            to the dev branch.
            <ul>
                <li>The code review will hopefully find ways to clean up the code, make it more easy to use, scalable, efficient, usable by the networking and graphics teams (this may require new changes to the API), as well as communicate the new design philosophy to the rest of the team.</li>
            </ul>
        </li>
        <li>
            Work with Ted to integrate the event queue into the ServerGameState class (in our initial graphics client-server integration, the event queue for player input events was implemented outside of the ServerGameState class).
        </li>
        <li>
            With the ServerGameState + SharedGameState abstract game state design more-or-less stable, the plan is to start adding gameplay features (copied from last week’s goals in the project specification schedule):
            <ul>
                <li>Implement basic player movement</li>
                <li>Implement basic enemy AI (i.e., NPC movement)</li>
                <li>If time allows, we should try to catch up with the project schedule and implement the following additional features: Trap Design / Implementation and Dungeon Master Logic</li>
            </ul>
        </li>
        <li>
            Web (lower priority - if time allows; prioritize the above Gameplay goals as they’re the most critical to moving the project forward)
            <ul>
                Contribute to the current website design (adding / modifying CSS)
            </ul>
        </li>
        <li>
            Music (lowest priority - as mentioned in last week’s report, this may be a goal that’s too early to realize, as the game is still brewing its image / feel).
            <ul>
                Come up with some musical ideas / leitmotifs for different points in the game (main menu theme, 3 players victory theme, Dungeon Master victory theme, 3 stages of escaping the maze (green / yellow / red depending on how much time is left))
            </ul>
        </li>
    </ul>

    <p>
        However, these changed somewhat as the week progressed; I shall explain further in the answer to the next question.
    </p>

    <h2>What goals were you able to accomplish?</h2>

    <p>
        We were able to complete goal 1 on Tuesday. After our meeting with the Professor on Tuesday, we drew out the redesign of the ServerGameState + SharedGameState on the white board in order to solve a final problem we had regarding object inheritance. Each Object in the ServerGameState needed to be mapped to a corresponding read-only SharedObject which would be a part of the SharedGameState representation that is generated by the server and sent to the client every timestep. A problem arose when we added object classes that derived from Object; for instance, assume we have a Player class which derives from Object. The Player class contains new information (e.g., a Health struct), some of which is shared with the client (e.g., current health value and maximum health value for displaying an HP bar) and some of which is not (e.g., health regen rate). As some objects are Players and others are not, not all objects have a Health struct, and as Health has some shared properties, Health must be mapped to a SharedHealth struct which would be sent to the client.
    </p>

    <p>
        To be “perfect,” we could mirror the server-side object inheritance tree in the shared game state representation; e.g., we could create a SharedPlayer class which derives from SharedObject and which contains a SharedHealth struct in addition to its base class’ properties. However, this would mean constantly maintaining the two inheritance trees to match each other; as the inheritance trees grow more complex, this may become unwieldy. This would have the benefit however of making sure that when the client receives a list of shared objects, all of the object fields would be valid.
    </p>

    <p>
        We settled on a different approach - each class that derives from Object maps to a SharedObject and whenever a new shared struct needs to be sent to the client as part of a shared object but which may not be needed by every object (such as SharedHealth), this shared struct is added to the SharedObject class as an optional field; i.e., instead of adding a SharedHealth struct to SharedObject directly, it will instead add a std::optionaL<SharedHealth> field.
    </p>

    <p>
        This is the lesser of two evils from our perspective, but it is by no means a perfect solution: this could cause unnecessary bloat when sending SharedObjects to the client and when writing client code, the programmer must be aware which of the optional shared structs are available in each object based on the derived object class that generated it. To assist in this, each Object and SharedObject have an ObjectType enum field which marks the kind of object that it is (this enum essentially equals the object’s class name).
    </p>

    <p>
        After we settled on this approach, the goal was to merge the new redesign of the game state so that we could start adding content features (as opposed to architectural features, these are assumed to only need to build upon the existing architecture by “filling” it with new content; as these are more localized, these could be done more-or-less in parallel, allowing more people contribute to the game state at once - this approach was pushed for by Tyler and it has allowed us to make progress in multiple aspects of the gamestate over the week). Tyler suggested another refactor of the ServerGameState to create an ObjectManager class that would encapsulate all object CRUD and bookkeeping; I implemented this and the new gamestate implementation was merged to dev on Tuesday evening.
    </p>

    <p>
        We were also able to accomplish goal 2 - I worked a bit with Ted to figure out how we could move part of the server-side event queue code into the ServerGameState (as all event handling should be done by the ServerGameState in the ServerGameState::update() function that computes the state of the next timestep from the current one). Ted implemented these changes and the update() method is now integrated into the server’s game loop.
    </p>

    <p>
        Goal 3 was changed; after the game state redesign was merged, I was assigned to determine how to encode maze map information in the ServerGameState (and potentially how to read it from a file). This was a bit more confusing than I expected, mainly since I tried to figure out how to best encode wall positions and dimensions. The problem was that each object has a position vector which marks its location in the game world, but this only marks a single point, and each object is a 3-D object with non-zero dimensions. The question arises therefore which point in the object is at the position vector’s coordinates. So far, we have implemented things to always treat the position vector as where the center of the object is in the game world. However for walls, this means that if a dimensions vector is maintained, the specified dimensions extend from the point marked by the position vector halfway in opposite directions. More precisely, if we have a wall that has dimensions (4, 4, 2) and is at position (0,0,0), the wall would extend in the x direction from -2 to 2, in the y direction from -2 to 2, and int the z direction from -1 to 1. This means that when specifying wall positions, the math is a bit unintuitive as we must think of the exact size of the wall rather than from where and to where it extends. Possibly a better approach (if anchor points are introduced) would be to place an object in the game world such that its lower corner from which it extends in the positive x and positive y directions would match its position vector as then you could add dimension components to position components to determine the “start” and “end” of an object.
    </p>

    <p>
        There’s also the problem of maze map representation - one approach suggested by Tyler is to use an Angband-y representation of the maze in a text file. In this approach, we can represent the maze as a 2-D grid in which each grid cell has the same dimensions (e.g., 1 meter x 1 meter). Each grid cell contains exactly one object. We can easily represent an environment in a text file by representing each grid cell as a character and assigning different characters to different objects.
    </p>

    <p>
        Example: if we specify the following character - object mapping, we can represent a maze as follows:
        <ul>
            <li>. => empty grid cell (no object except for the floor and ceiling)</li>
            <li># => wall</li>
            <li>+ => closed door</li>
            <li>X => lava trap</li>
            <li>M => monster spawn point</li>
            <li>I => item</li>
        </ul>
    </p>
    <p>
        Example maze:

        <pre>
            ############
            # M #  X  X#
            #   #  #   #
            ##+##  #   #
            #   I  #   #
            #      #   #
            ######### ##
        </pre>
    </p>
    <p>
        This has the advantage that maze design is easy to integrate to the ServerGameState - we can design mazes visually. Additionally, we can avoid the problem of calculating object placement vectors as this will be largely automated based on how the objects are generated upon reading this text file (e.g., the top-left corner could be specified to be position (0,0)).
    </p>

    <p>
        However, there are potential downsides to this: it may create more objects than necessary (e.g., a line of wall objects should be converted into a single long wall as opposed to multiple small walls; this would require an additional “wall coalescing” algorithm. Such an algorithm may require adding an intermediate representation between reading the maze text file and the generated corresponding Objects (for instance, one program flow could be read the text file, convert into a 2-D array of GridCells, perform the coalescence algorithm, then convert the coalesced GridCells into Objects)).
    </p>

    <p>
        Additionally, this limits object position possibilities (since objects are placed in jumps of grid cell dimensions and each grid cell contains at most one object - this could be partially addressed by specifying for each object type where within the grid cell it should spawn (i.e., via adding a position offset vector within the grid-cell)).
    </p>

    <p>
        An alternative approach would be to specify each object in the maze directly in a JSON representation; this would alleviate parsing difficulties (as a library could be used) and remove any additional complexity (such as the coalescence algorithm + intermediate representation), but we’d lose the benefit of easy maze design.
    </p>

    <p>
        At present, I have made a simple initial implementation for maze walls and created a room to test it (it can’t be rendered properly yet, but the wall objects are placed in the ServerGameState). We still need to decide as a team regarding the two above maze encoding options.
    </p>
    <p>
        I wasn’t able to accomplish either of the lower-priority goals 4 and 5.
    </p>

    <h2>If the week went differently than you had planned, what were the reasons?</h2>
    <p>
        As mentioned above, goal 3 was changed to fit implementing the ObjectManager and working on maze environment representation. I hadn’t expected maze environment representation to take a while to figure out as there are details I had taken for granted.
    </p>

    <h2>What are your specific goals for the next week?</h2>
    <ul>
        <li>
            Gameplay
            <ul>
                <li>
                    Fix weird Boost issue that occurred by updating Boost from 1.82.0 to 1.85.0 (a new error has popped up that doesn’t actually stop anything from building but is concerning). I’ll probably need Tyler’s help to figure this out.
                    <ul>
                       <li><b>Editor's Note: </b>🫡</li>
                    </ul>
                </li>
                <li>
                    Improve the existing environment implementation (SolidSurface and using it):
                    <ul>
                        <li>
                            Add anchor points (or at least a lower-corner anchor point) if they are helpful for easier level design.
                        </li>
                        <li>
                            Discuss maze file design (this will affect other aspects of how the environment works in the ServerGameState since if we use the angband-y maze representation, we may not need to worry about anchor points) with the rest of the team and reach a consensus, then design and implement that system (i.e., angband-y maze representation, JSON file, maybe something else entirely?).
                        </li>
                        <li>
                            Using this new system, create a small maze level proof-of-concept to replace the current “moving cube” client-server integration (moving towards Mini Milestone 2).
                        </li>
                    </ul>
                </li>
                <li>
                    Work with Ted on integrating collision calculations to the ServerGameState. All objects that have a collider can collide with other objects that also have a collider. Need to integrate collision detection calculations + collision response to the ServerGameState::update() method.
                </li>
            </ul>
        </li>
        <li>
            Debugger (lower priority)
            <ul>
                <li>
                    As the ServerGameState and SharedGameState change, the debugger goes out of date (new properties are added that don’t get printed in object to_string()s, for instance, and the debugger needs to recognize new properties).
                    <ul>
                        <li>Keep the debugger updated to the current implementation of ServerGameState and SharedGameState (all properties recognized).</li>
                        <li>Add an ability for the user to simulate receiving player input events; these will be pushed to the debugger’s maintained event queue in order and handled when the user enters the step command (which calls ServerGameState::update()).</li>
                    </ul>
                </li>

            </ul>
        </li>
        <li>
            Web (low priority - if time allows; prioritize the above Gameplay goals as they’re the most critical to moving the project forward)
            <ul>
                <li>Contribute to the current website design (adding / modifying CSS)</li>
            </ul>
        </li>
        <li>
            Music (lowest priority - as mentioned in last week’s report, this may be a goal that’s too early to realize, as the game is still brewing its image / feel).
            <ul>
                <li>Come up with some musical ideas / leitmotifs for different points in the game. As the game is set in a sort of Mythological Greece, it may make sense to create leitmotifs for different Greek gods that may appear in the game as well as for the heroes that the players play as.</li>
                <li>Come up with musical ideas / themes / leitmotifs for: main menu theme, 3 players victory theme, Dungeon Master victory theme, and 3 stages of escaping the maze (green / yellow / red depending on how much time is left)). (For certain hero / DM abilities, it may make sense to play a short leitmotif (e.g. for power ups or special abilities)).</li>
            </ul>
        </li>
    </ul>

    <h2>What did you learn this week, if anything (and did you expect to learn it?)</h2>
    <ul>
        <li>
            From my recollection, I learned a few new things in C++, such as basic usage of std::shared_ptr. I also learned a bit more about the problem of storing the maze environment.
            <ul>
                <li>
                    <b>Editor's Note: </b> As evidenced above, Gil's recollection is amazing.
                </li>
            </ul>
        </li>
    </ul>

    <h2>What is your individual morale (which might be different from the overall group morale)?</h2>
    <ul>
        <li>
            I fear I may be a bit behind now (since there are still a few features to add to get to our mini milestone 2 and many to get to our MVP), but I’m also fired up to add them in. Now that the gamestate architecture has more-or-less stabilized, we can focus on adding “content” features that are more localized and build on the existing architecture.
        </li>
    </ul>
</body>

</html>